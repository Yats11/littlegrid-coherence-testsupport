<html>
<body>
<p>
This package contains the main API for interacting with a cluster member group - this is
the way to start a Coherence cluster within a single JVM and then interact with it as a
storage disabled member or an Extend client.
</p>
This framework has the following motivations:
<ul>
    <li>
        To have the smallest API possible, but to also provide enough control to support
        the varied use cases and ways that Coherence is used.
    </li>
    <li>
        To enable you to do your job and work with Coherence and not get in the your way,
        the intention is that you should only need to reference the classes within this framework
        in order to start-up and control a cluster - no more, it should not intrude into your
        code-base.
    </li>
    <li>
        To have the minimum dependencies, but still be functional - presently to use this framework,
        you just need the LittleGrid JAR and a version of Coherence (currently 3.5.3 -
        3.7.1.0 have been tested).
    </li>
    <li>
        To enable use of the LittleGrid within simple Java application or within a test
        framework such as JUnit or TestNG - the choice is yours.
    </li>
    <li>
        To enable you to control the cluster member group construction through code using a fluent
        builder API or through simple key/values in a properties object.
    </li>
</ul>
<p/>
Examples of use
<ul>
    <li>Within a standard Java application main(String[] args):
        <pre>
public class SimpleApp {
    public static void main(String[] args) {
        final String key = "123";

        ClusterMemberGroup memberGroup = null;

        try {
            memberGroup = ClusterMemberGroupUtils.newClusterMemberGroupBuilder()
                    .setStorageEnabledCount(2).build();

            final NamedCache cache = CacheFactory.getCache("test");

            cache.put(key, "hello");
            System.out.println(cache.get(key));
        } finally {
            ClusterMemberGroupUtils.shutdownCacheFactoryThenClusterMemberGroups(memberGroup);
        }
    }
}
        </pre>

    </li>
    <li>Within a testing framework, such as JUnit:
        <pre>
public class SimpleTest {
    private static ClusterMemberGroup memberGroup;

    &#64;BeforeClass
    public static void beforeTests() {
        memberGroup = ClusterMemberGroupUtils.newClusterMemberGroupBuilder()
                .setStorageEnabledCount(2).build();
    }

    &#64;AfterClass
    public static void afterTests() {
        ClusterMemberGroupUtils.shutdownCacheFactoryThenClusterMemberGroups(memberGroup);
    }

    &#64;Test
    public void simpleExample() {
        NamedCache cache = CacheFactory.getCache("test");
        cache.put("key", "hello");

        assertEquals(1, cache.size());
    }
}
        </pre>
    </li>
    <li>A JUnit test with an Extend proxy and two storage members configured through a properties object instead
        of using the fluent API:
        <pre>
    ...
    &#64;Test
    public void exampleOfConfiguringExtendProxyWithSeparateStorageEnabledMembersThroughProperties() {
        /*
            This properties could be read from a file.
         */
        Properties properties = new Properties();
        properties.setProperty("StorageEnabledCount", "2");
        properties.setProperty("ExtendProxyCount", "1");
        properties.setProperty("CacheConfiguration", TCMP_CLUSTER_MEMBER_CACHE_CONFIG_FILE);
        properties.setProperty("ClientCacheConfiguration", EXTEND_CLIENT_CACHE_CONFIG_FILE);

        memberGroup = ClusterMemberGroupUtils.newClusterMemberGroupBuilder().setBuilderProperties(properties).build();

        NamedCache cache = CacheFactory.getCache("known-extend-cache");
        cache.put("key", "value");

        assertThat(cache.size(), is(1));
        assertThat((String) cache.get("key"), is("value"));
    }
        </pre>
    </li>
</ul>
</body>
</html>
